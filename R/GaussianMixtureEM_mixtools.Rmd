---
title: "混合正規分布のEM最尤推定"
author: "ryamada"
date: "2019年12月11日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 混合分布のEM最尤推定

混合分布そのままだとEMでパラメタ更新しにくいので、次のようにする。

混合数を決めたら、各標本が、何番目の構成分布からの標本なのかを割り付けの対象とし、

その割り付け自体も最尤推定の対象とした上で、

構成分布のパラメタ推定値を定め、E・Mで更新する

## mixtoolsパッケージを使ってやってみる

１次元正規分布の混合分布でやってみる。

混合数を5としてデータを作成し、

推定混合数を2,3,4,5,6,7,8として試してみる。
```{r}
#install.packages("mixtools")
library(mixtools)
library(MCMCpack)

# 混合数
n.norm <- 5
# 各構成正規分布の平均をばらつかせる
m <- sample(0:10,n.norm)*20 
# 標準偏差は小さめにして、各構成分布がくっきりと分かれるようにする
s <- sample(1:5,n.norm,replace=TRUE) 
# 混合比。これも比較的均等な値として、推定しやすい標本セットとする
lmbd <- rdirichlet(1,rep(10,n.norm))
# 標本数も多めにして、推定を容易にする
n <- 10000
# 混合正規乱数を発生する関数
my.rmixnorm <- function(n,lmbd,m,s){
	k <- rmultinom(1,n,lmbd)
	res <- c()
	for(i in 1:length(k)){
		tmp <- rnorm(k[i],m[i],s[i])
		res <- c(res,tmp)
	}
	res
}
# 標本セットを作る
obs <- my.rmixnorm(n,lmbd,m,s)
hist(obs)
```

EM推定してみる。

mixtoolsパッケージのnormalmixEM()関数は、標本が必須引数で、混合数はデフォルトが2。今回は、複数の混合数を指定するので、明示的に指定して実行する。

EMアルゴリズムは、初期値依存があるので、

構成正規分布の平均と標準偏差の初期値を与えることもできる。

また、混合比の初期値も与えることができる。

EMアルゴリズムは尤度の改善が十分小さくなったら終了するというものなので、収束閾値も指定できる。
指定しなければデフォルト値で終了する。

また、収束が難しいタスクの場合に、処理が終了することを保証するために、繰り返し処理の最大数も指定できる。デフォルト値も与えられている。

混合数は、真の混合数より明らかに少ない2から、明らかに多い、8までとして推定してみる。

```{r}
# 混合数を2から8とする
ks <- 2:(n.norm+3)
# 各混合数の推定結果を格納するオブジェクト
out <- list()

for(i in 1:length(ks)){
	k <- ks[i]
	# ほぼデフォルト設定で推定する
	out[[i]] <- normalmixEM(obs,k=k)
	# パッケージには各結果を視覚表示する関数があるので、それを使って表示してみる
	plot(out[[i]], density=TRUE, cex.axis=1.4, cex.lab=1.4, cex.main=1.8,main1=paste("k=",ks[i]))

}
```

各混合数での、対数尤度の改善履歴をプロットしてみる。

最大繰り返し数が(デフォルトで)1000なので、1001個の対数尤度を格納できるようにする。

場合によっては、少ない繰り返し数で収束して、終了することもあるので、その場合は、打ち切られたことがわかるよう、小さな尤度に下がるようにしておく。

一部の混合数では、高い対数尤度が得られ、その値はほぼ同じになっており、

不十分な尤度までしか上がらない混合数があることもわかる。

尤度の上昇が不十分なのは、基本的には推定指定混合数が真の混合数より小さい場合である。

その場合には、モデルの単純さの限界の中で最大尤度に到達し収束するらしく、繰り返しが1000回に達していないことがわかる。
```{r}
loglikes <- matrix(out[[1]]$all.loglik[1],1001,length(ks))

for(i in 1:length(ks)){
	loglikes[1:length(out[[i]]$all.loglik),i] <-out[[i]]$all.loglik
	print(out[[i]]$loglik) # 最終的に出た最大尤度を表示させておく
}

matplot(loglikes,type="l")
```

十分に尤度が高くなった指定混合数は5,6,7,8であることを以下に示す。

混合数が真の値の場合は、混合数が真の値より大きい場合に比べて、対数尤度の増大は遅いが、「収束した」と判断されて、終了していることがわかる。

混合数が真の値より大きい場合は、無理なチューニングをするせいか、収束せずに処理が続いていることがわかる。

または、局所解に陥ってしまって、対数尤度が上がらない場合もある。
その場合の構成分布のパラメタ推定値は適当でなくなるのは当然である。

乱数を使って実施しているので、試行ごとにどのような結果になるかは、変化する。

```{r}
matplot(loglikes[,4:length(ks)],type="l")
```

真の混合数の場合の推定値と、モデル真値とを比べてみる。

平均値の大小順に並べ替えて表示する。

うまくいっていれば、ごくよい一致を示すはずであり、局所解に陥っていれば不適当な推定値になっている。

```{r}
ord.model <- order(m)
ord.est <- order(out[[4]]$mu)
# 平均
# モデル真値
m[ord.model]
# k=5での推定値
out[[4]]$mu[ord.est]
# 標準偏差
s[ord.model]
out[[4]]$sigma[ord.est]
# 混合比
lmbd[ord.model]
out[[4]]$lambda[ord.est]
```