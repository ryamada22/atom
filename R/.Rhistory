Wd <- RL$L %*% t(Wc) %*% RL$L
# 行・列入れ替え
s <- sample(1:length(Wc[,1]))
S <- diag(length(s))[,s]
Wc. <- S %*% Wc %*% t(S)
Wd. <- S %*% Wd %*% t(S)
# 双対グラフのゼータ関数向けの接続行列を作る
We <- Wc + Wd
We. <- Wc. + Wd.
# 複素行列
# このWc.cpx,Wd.cpxは、時計回りに部分を切り取るときに、時計回りエッジを選択する場合と
# 反時計回りに部分を切り取るときに、反時計回りエッジを選択する場合
ret.steps <- my.return.step(Wc)
Wc.cpx <- my.complex.W(Wc,counterclockwise=FALSE)
#Wd.cpx <- my.complex.W(Wd,counterclockwise=FALSE)
Wd.cpx <- RL$L %*% t(Conj(Wc.cpx)) %*% RL$L
opp.cpx <- my.complex.W.opp(Wc.cpx,Wd.cpx,RL$L)
# 4行列を追合関係の２行列にする
ZeroMat <- matrix(0,length(Wc.cpx[,1]),length(Wc.cpx[,1]))
W <- rbind(cbind(Wc.cpx,ZeroMat),cbind(ZeroMat,opp.cpx$Wc4d))
W.star <- rbind(cbind(opp.cpx$Wd4c,ZeroMat),cbind(ZeroMat,Wd.cpx))
if(L.sort){
SS <- my.L.sort(RL$L)
WR4R=t(SS) %*% Wc.cpx %*% SS
WL4L=t(SS) %*% Wd.cpx %*% SS
WR4L = t(SS) %*% opp.cpx$Wc4d %*% SS
WL4R = t(SS) %*% opp.cpx$Wd4c %*% SS
# 4行列を追合関係の２行列にする
ZeroMat <- matrix(0,length(Wc.cpx[,1]),length(Wc.cpx[,1]))
W <- rbind(cbind(WR4R,ZeroMat),cbind(ZeroMat,WR4L))
W.star <- rbind(cbind(WL4R,ZeroMat),cbind(ZeroMat,WL4L))
return(list(Wc=t(SS) %*% Wc %*% SS,Wd=t(SS) %*% Wd %*% SS,We=t(SS) %*% We %*% SS,Wc.=t(SS) %*% Wc. %*% SS, Wd.=t(SS) %*% Wd. %*% SS,We.=t(SS) %*% We. %*% SS,WR4R=WR4R, WL4L=WL4L, WR4L=WR4L,WL4R = WL4R,W = W, W.star = W.star , R = t(SS) %*% RL$R %*% SS , L = t(SS) %*% RL$L %*% SS,F=F,EL=EL,E.pair=E.pair))
}else{
return(list(Wc=Wc,Wd=Wd,We=We,Wc.=Wc.,Wd.=Wd.,We.=We.,WR4R=Wc.cpx,WL4L=Wd.cpx,WR4L = opp.cpx$Wc4d, WL4R = opp.cpx$Wd4c, W=W, W.star = W.star,R = RL$R, L = RL$L,F=F,EL=EL,E.pair=E.pair))
}
}
# 雑な関数ではあるが
# 行列のn乗を返す関数
# power of Matrix
my.powM <- function(M,n){
d <- length(M[,1])
ret <- diag(d)
for(i in 1:n){
ret <- ret %*% M
}
return(ret)
}
# 固有値 -1 については、-1 + 0iと-1 - 0iとが同数になるように一工夫してある
my.powM2 <- function(M,n){
eigen.out <- eigen(M)
eval.WcWd <- eigen.out[[1]]
close2one <- which(Arg(eval.WcWd)/pi > 1- (10)^(-10))
eval.WcWd[close2one] <- rep(c(exp(1i * (-1)*pi),exp(1i * pi)),length(close2one)/2)
eigen.out[[1]] <- eval.WcWd
#eigen.out <- eigen(M)
tmp <- solve(eigen.out[[2]])
eigen.out[[2]] %*% diag(eigen.out[[1]]^n) %*% tmp
}
# 行列のトレースを返す
# Trace of matrix
my.trace <- function(M){
sum(diag(M))
}
# 適当に三角メッシュ平面グラフの情報を返す
# fは、頂点のトリオを時計回り(反時計回りと見なしても良い)に並べた行からなる３列行列
# Fの各行に向きのある辺の番号を与えたものとしてい作った３列行列
# generates a random triangular planar graph information
# F is a matrix with 3 columns; each row has three integers that represent three edges that are in the order of clockwise rotation (or you can consider the order as counterclockwise.)
# Returned values = F and f
# F's row is just a three numbers of each triangle.
# f is a matrix whose each row is consisted of three vertex ids in clockwise rotation order.
my.rtri <- function(n){
f <- matrix(1:3,ncol=3)
f <- rbind(f,3:1)
for(i in 1:n){
s <- sample(1:length(f[,1]),1)
v <- max(f) + 1
sf <- f[s,]
f <- f[-s,]
f <- rbind(f,c(sf[1:2],v))
f <- rbind(f,c(sf[2:3],v))
f <- rbind(f,c(sf[c(3,1)],v))
}
F <- matrix(1:(length(f[,1])*3),byrow=TRUE,ncol=3)
return(list(f=f,F=F))
}
# すべての3角形をn回ずつ分割する
my.div.tri <- function(f,n){
el <- rbind(f[,1:2],f[,2:3],f[,c(3,1)])
max.v <- max(c(el))
el. <- t(apply(el,1,sort))
el.v <- el.[,1] + (max.v+1) * el.[,2]
ord <- rank(el.v,ties.method="max")/2 + max.v # 該当エッジに発生させる新頂点のID番号
for(i in 1:n){
len <- length(f[,1])
for(j in 1:len){
v1 <- ord[j]
v2 <- ord[len+j]
v3 <- ord[2*len+j]
sf <- f[1,]
f <- f[-1,]
f <- rbind(f,c(sf[1],v1,v3))
f <- rbind(f,c(sf[2],v2,v1))
f <- rbind(f,c(sf[3],v3,v2))
f <- rbind(f,c(v1,v2,v3))
}
}
F <- matrix(1:(length(f[,1])*3),byrow=TRUE,ncol=3)
return(list(f=f,F=F))
}
# ３角形の頂点情報から、エッジリストを作る
# my.rtri()関数の出力の$fから作る
# エッジの並び順は、my.rtri()関数の出力の$Fとうまく合致するように並べ替えて出力してある
# The function makes an edgelist with direction
my.EfromF <- function(f){
el <- rbind(f[,1:2],f[,2:3],f[,c(3,1)])
tmp <- matrix(1:length(el[,1]),ncol=3)
el <- el[c(t(tmp)),]
return(el)
}
# 向きの違うエッジのペアを、my.EfromF()関数の出力での行番をエッジＩＤと見なして返す
# The return is two-column matrix and each row is the number of edges paring in mutually opposite direction.
my.Epair <- function(el){
s.el <- apply(el,1,sort)
mv <- max(el)+1
V <- s.el[1,] * mv + s.el[2,]
tmp <- outer(V,V,"-")
diag(tmp) <- 1
pairs <- which(tmp==0,arr.ind=TRUE)
return(pairs)
}
# 三角メッシュの各面の接続に相当する行列Ｒと
# 逆向きエッジ対応に相当する行列Ｌとを返す
# This function returns two square matrices, R and L
# R %*% L is the edge-connection matrix of clockwise rotation
my.permMat <- function(F,EL,E.pair){
n <- length(E.pair[,1])
R <- matrix(0,n,n)
trio.mat <- matrix(0,3,3)
trio.mat[1,2] <- trio.mat[2,3] <- trio.mat[3,1] <- 1
for(i in 1:length(F[,1])){
R[F[i,],F[i,]] <- trio.mat
}
L <- matrix(0,n,n)
for(i in 1:length(E.pair[,1])){
el1 <- EL[E.pair[i,1],]
el2 <- EL[E.pair[i,2],]
tmp1 <- which(apply((t(EL) - el1)^2,2,sum)==0)
tmp2 <- which(apply((t(EL) - el2)^2,2,sum)==0)
L[tmp1,tmp2] <- 1
}
return(list(R=R,L=L))
}
# 何歩で戻るかを列挙する関数
my.return.step <- function(Wc){
returned <- list()
for(i in 1:length(Wc[,1])){
returned[[i]] <- 0
}
for(i in 1:length(Wc[,1])){
tmp <- diag(my.powM(Wc,i))
if(sum(tmp)>0){
for(j in which(tmp==1)){
returned[[j]] <- c(returned[[j]],i)
}
}
}
returned. <- lapply(returned,function(x){x[-1]})
returned.
}
# 何歩で戻るかの情報で、Wc行列を複素行列化
# この関数は、時計回りに部分を切り取るときに、時計回りエッジを選択する場合と
# 反時計回りに部分を切り取るときに、反時計回りエッジを選択する場合
my.complex.W <- function(Wc,counterclockwise=TRUE){
returned <- my.return.step(Wc)
tmp <- sapply(returned,min)
ret <- Wc
pm <- 1
if(!counterclockwise){
pm <- -1
}
for(i in 1:length(tmp)){
val <- exp(pm * 1i * 1/tmp[i]*2*pi)
loc <- which(ret[i,]==1)
ret[i,loc] <- val
}
return(ret)
}
# この関数は、時計回りに部分を切り取るときに、反時計回りエッジと選ぶ場合と
# 反時計回りに部分を切り取るときに、時計回りエッジを選ぶ場合
# Wc,Wdは時計回り・反時計回りの複素行列,Pはエッジ対応行列
my.complex.W.opp <- function(Wc,Wd,P){
Wd4c <- Wd # clockwiseに切り取るときのdエッジ選択
for(i in 1:length(Wc[,1])){
tmpd <- which(Wd[i,] != 0)
tmpc <- which(Wc[i,] != 0)
counter <- which(P[tmpc,] != 0)
tmpc2 <- which(Wc[counter,] != 0)
#print(Wc[i,tmpc])
#print(Wc[counter,tmpc2])
#print("0000")
Wd4c[i,tmpd] <- Wc[i,tmpc] * Wc[counter,tmpc2] / exp(1i * pi)
}
Wc4d <- P %*% t(Conj(Wd4c)) %*% t(P)
return(list(Wd4c=Wd4c,Wc4d=Wc4d))
}
# 有向辺のペアをあらわした行列Lを引数にして、(1,2),(2,3),...とそろえるために、エッジの番号付けを変換するための置換行列を返す関数
my.L.sort <- function(L){
pairs <- which(L==1,arr.ind=TRUE)
pairs <- pairs[which(pairs[,1]<pairs[,2]),]
sfl <- c(t(pairs))
SS <- diag(length(sfl))[,sfl]
return(SS) # t(SS) %*% L %*% SS is the sorting calculation
}
# ランダムに三角形planar graphを作り、それに関する辺接続行列等を返す関数
my.rTriRL <- function(n.tri,L.sort=TRUE){
F <- my.rtri(n.tri)
EL <- my.EfromF(F$f)
E.pair <- my.Epair(EL)
RL <- my.permMat(F$F,EL,E.pair)
# RL出力から、双対グラフの時計回り接続行列を作る
Wc <- RL$L %*% RL$R
# 双対グラフの反時計回り接続行列を作る
Wd <- RL$L %*% t(Wc) %*% RL$L
# 行・列入れ替え
s <- sample(1:length(Wc[,1]))
S <- diag(length(s))[,s]
Wc. <- S %*% Wc %*% t(S)
Wd. <- S %*% Wd %*% t(S)
# 双対グラフのゼータ関数向けの接続行列を作る
We <- Wc + Wd
We. <- Wc. + Wd.
# 複素行列
# このWc.cpx,Wd.cpxは、時計回りに部分を切り取るときに、時計回りエッジを選択する場合と
# 反時計回りに部分を切り取るときに、反時計回りエッジを選択する場合
ret.steps <- my.return.step(Wc)
Wc.cpx <- my.complex.W(Wc,counterclockwise=FALSE)
#Wd.cpx <- my.complex.W(Wd,counterclockwise=FALSE)
Wd.cpx <- RL$L %*% t(Conj(Wc.cpx)) %*% RL$L
opp.cpx <- my.complex.W.opp(Wc.cpx,Wd.cpx,RL$L)
# 4行列を追合関係の２行列にする
ZeroMat <- matrix(0,length(Wc.cpx[,1]),length(Wc.cpx[,1]))
W <- rbind(cbind(Wc.cpx,ZeroMat),cbind(ZeroMat,opp.cpx$Wc4d))
W.star <- rbind(cbind(opp.cpx$Wd4c,ZeroMat),cbind(ZeroMat,Wd.cpx))
if(L.sort){
SS <- my.L.sort(RL$L)
Wc4c.cpx=t(SS) %*% Wc.cpx %*% SS
Wd4c.cpx=t(SS) %*% Wd.cpx %*% SS
Wc4d.cpx = t(SS) %*% opp.cpx$Wc4d %*% SS
Wd4c.cpx = t(SS) %*% opp.cpx$Wd4c %*% SS
# 4行列を追合関係の２行列にする
W <- rbind(cbind(Wc4c.cpx,ZeroMat),cbind(ZeroMat,Wc4d.cpx))
W.star <- rbind(cbind(Wd4c.cpx,ZeroMat),cbind(ZeroMat,Wd4c.cpx))
return(list(Wc=t(SS) %*% Wc %*% SS,Wd=t(SS) %*% Wd %*% SS,We=t(SS) %*% We %*% SS,Wc.=t(SS) %*% Wc. %*% SS, Wd.=t(SS) %*% Wd. %*% SS,We.=t(SS) %*% We. %*% SS,Wc4c.cpx=Wc4d.cpx ,Wd4d.cpx=Wd4d.cpx,Wc4d.cpx = Wc4d.cpx, Wd4c.cpx = Wdec.cpx, W = W, W.star = W.star,R = t(SS) %*% RL$R %*% SS , L = t(SS) %*% RL$L %*% SS,F=F,EL=EL,E.pair=E.pair))
}else{
return(list(Wc=Wc,Wd=Wd,We=We,Wc.=Wc.,Wd.=Wd.,We.=We.,Wc4c.cpx=Wc.cpx,Wd4d.cpx=Wd.cpx,Wc4d.cpx = opp.cpx$Wc4d, Wd4c.cpx = opp.cpx$Wd4c, W=W,W.star=W.star,R = RL$R, L = RL$L,F=F,EL=EL,E.pair=E.pair))
}
}
n.tri <- 8
F1 <- my.rtri(n.tri)
f1 <- F1$f
out1 <- my.W.cpx(f1)
# サッカーボール
# の三角メッシュ
football.tri <- rbind(c(1,7,4),c(4,7,8),c(1,9,7),c(1,2,9),c(2,23,9),c(2,3,23),c(3,29,23),c(3,19,29),c(3,13,19),c(2,13,3),c(2,10,13),c(1,10,2),c(1,5,10),c(1,4,5),c(4,6,5),c(4,8,6),c(6,8,17),c(8,26,17),c(17,26,31),c(17,31,16),c(6,17,16),c(11,6,16),c(5,6,11),c(5,11,12),c(10,5,12),c(10,12,13),c(13,12,14),c(13,14,19),c(8,21,26),c(8,7,21),c(7,22,21),c(7,9,22),c(9,23,22),c(22,23,25),c(23,29,25),c(16,31,32),c(16,32,15),c(16,15,11),c(11,15,12),c(12,15,14),c(15,32,18),c(15,18,14),c(14,18,19),c(20,19,18),c(29,19,20),c(26,27,31),c(27,26,24),c(26,21,24),c(21,22,24),c(24,22,25),c(27,24,28),c(24,25,28),c(25,29,28),c(28,29,20),c(31,27,30),c(27,28,30),c(28,20,30),c(32,31,30),c(18,32,30),c(20,18,30))
f1 <- football.tri
W <- out1$W
W.star <- out1$W.star
Wx <- W %*% W.star
plot(eigen(Wx)[[1]])
Wc <- out1$Wc
Wd <- out1$Wd
Wxx <- Wc %*% Wd
plot(eigen(Wxx)[[1]])
#Wx <- W.star %*% W
Wxpow <- list()
X <- diag(length(Wx[,1]))
for(i in 1:(length(Wx[,1])*2)){
Wxpow[[i]] <- Wx %*% X
X <- Wxpow[[i]]
}
sumMod <- sapply(Wxpow,function(x){sum(Mod(diag(x)))})
plot(sumMod)
ss <- which(sumMod > 1)
diags <- lapply(Wxpow,diag)
diags2 <- matrix(0,length(diags),length(diags[[1]]))
for(i in 1:length(diags)){
diags2[i,] <- diags[[i]]
}
image(Mod(diags2))
# Complexity of graph; the number of spanning trees
library(complexplus)
We <- out1$We
U <- We/3*2 - diag(length(We[,1]))/3
U2 <- U %*% U
U2plus <- U2 > 0.01
I <- diag(length(We[,1]))
N <- 1000
us <- 1 + seq(from = -0.0001,to = 0.0001,length=2*N+1)
m <- length(We[,1])/2 # |E|
n <- m/3 * 2
dets <- rep(0,length(us))
for(i in 1:length(dets)){
dets[i] <- Det(I - us[i] * We)/(1-us[i]^2)^(m-n)
}
plot(us,dets)
kappa <- (dets[N+2]-dets[N])/(us[N+2]-us[N])/(2*(m-n))
##########
W <- out1$We
#W. <- W * (rnorm(length(W))*0.01+1) # 辺に重みをつけてみる？？
eigen.out <- eigen(W)
plot(eigen.out[[1]])
#作成されたグラフのいわゆるk (|E|=3k,...)は、
k <- length(W[,1])/6
ones <- ones.neg <- twos <- twos.neg <- others <- c()
for(i in 1:length(eigen.out[[1]])){
if(identical(all.equal(Mod(eigen.out[[1]][i]),1),TRUE)){
if(Re(eigen.out[[1]][i]) >0){
ones <- c(ones,i)
}else{
ones.neg <- c(ones.neg,i)
}
}else if(identical(all.equal(Mod(eigen.out[[1]][i]),2),TRUE)){
if(Re(eigen.out[[1]][i]) >0){
twos <- c(twos,i)
}else{
twos.neg <- c(twos.neg,i)
}
}else{
others <- c(others,i)
}
}
print(paste("k=",k))
print("値2の固有値数:1のはず")
length(twos) # 1のはず
print("値-2の固有値数:0のはず")
length(twos.neg) # 0のはず
print("値1の固有値数:k+1のはず")
length(ones) # k+1のはず
print("値-1の固有値数:kのはず")
length(ones.neg) # kのはず
print("その他の値の固有値数:4k-2のはず")
length(others) # 6k - (1+0+(k+1)+k) = 4k -2 のはず
print("固有値の積:(-1)^k * 2^{2k}のはず") # 2^n = (-1)^k * 2^{2k}のはず
prod(eigen.out[[1]])
2^(2*k)
print("固有値の積を2を底として対数:2kのはず")
log2(abs(prod(eigen.out[[1]]))) # 2kに一致するはず
Nls <- c()
for(i in 1:100){
Nls <- c(Nls,sum(eigen.out[[1]]^i))
}
sprintf("%10f", Nls)
# 第一処理。Wc,Wdのランダム作成を関数化してみます
my.randWcWd <- function(d){
# d <- 8 　　　#dは引数になるのでコメントアウトします
Id <- diag(d)
s <- sample(d)
s
Wc <- Id[,s]
sp <- sample(d)
sp
sp.pair <- matrix(sp,ncol=2)
sp.pair
P <- matrix(0,d,d)
for(i in 1:length(sp.pair[,1])){
P[sp.pair[i,1],sp.pair[i,2]] <- 1
P[sp.pair[i,2],sp.pair[i,1]] <- 1
}
Wd <- P %*% t(Wc) %*% P
# 出力します
return(list(Wc=Wc,Wd=Wd))
}
# d個の有向辺に1,2,...,dというラベルをつけ
# そのラベルをWc,Wdで移動させ、それを記録する
my.zigzag <- function(Wc,Wd){
d <- length(Wc[,1])
ret <- matrix(0,d,2*d+1)
tmp <- 1:d
ret[,1] <- tmp
cnt <- 2
# Wc,Wdの２歩をd回繰り返す
for(i in 1:d){
tmp2 <- Wc %*% tmp
# order()関数で、1,2,...,dというラベルの「位置」情報を
# 取り出して格納する
ret[,cnt] <- order(tmp2)
tmp3 <- Wd %*% tmp2
ret[,cnt+1] <- order(tmp3)
cnt <- cnt + 2
tmp <- tmp3
}
return(ret)
}
# 以下の出力オブジェクト series：
# 各行はそれぞれの行に相当する有向辺を起点として
# サイクル構成辺idが並んでいる
# Wc/Wdのサイクルが同一か否かは
# 奇数歩目が作るid集合の一致・不一致で確認できる
my.odd.unique <- function(x){
len <- length(x[1,])
odds <- x[,seq(1,len,2)]
# oddsの各行から、サイクル構成有向辺idに1を立て
# それ以外を0にしたベクトルを作成し
# d x d の0,1行列 を作る
# apply()関数にベクトルを返す関数を与えると
# 行・列が反転するので、apply()関数の出力を転置している
tmp <- t(apply(odds,1,function(x,d){v=rep(0,length(x));v[x] <- 1;return(v)},d=length(x[,1])))
# 重複行除去
# duplicated()関数に行列を渡すと、重複行か否かをTRUE/FALSEで返すので
# outoutのFALSE行を取り出せば
# ユニークなサイクルの情報が取れる
unique.mat <- x[!duplicated(tmp),]
return(unique.mat)
}
# seriesからサイクル部分を抽出する
# 奇数歩目に自身に戻っていることを取り出す
my.odd.return <- function(x){
len <- length(x)
odds <- x[seq(1,len,2)]
retid <- which(odds==odds[1])[2]
return(x[1:(retid*2-2)])
}
my.zigzag.cycle <- function(f){
WcWd <- my.W(f)
series <- my.zigzag(WcWd$Wc,WcWd$Wd)
unique.series <- my.odd.unique(series)
cycles <- apply(unique.series,1,my.odd.return)
if(is.matrix(cycles)){
ret <- list()
for(i in 1:length(cycles[1,])){
ret[[i]] <- cycles[,i]
}
cycles <- ret
}
return(cycles)
}
tet.antiprism6 <- my.paste.tri(tetra,antiprism6,1,3)
cy.tetra <- my.zigzag.cycle(tetra)
cy.antiprism6 <- my.zigzag.cycle(antiprism6)
cy.tet.antiprism6 <-my.zigzag.cycle(tet.antiprism6)
# icosa
# heccaideca
ico.heccai <- my.paste.tri(isosa, heccaideca, 1,5)
# 正三角形でできた立体たち
# 正多面体３種
tetra <- rbind(c(1,2,3),c(1,3,4),c(1,4,2),c(3,2,4))
octa <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,2,5),c(6,3,2),c(6,4,3),c(6,5,4),c(6,2,5))
icosa <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,5,6),c(1,6,2),c(3,2,7),c(4,3,8),c(5,4,9),c(6,5,10),c(2,6,11),c(3,7,8),c(4,8,9),c(5,9,10),c(6,10,11),c(2,11,7),c(12,8,7),c(12,9,8),c(12,10,9),c(12,11,10),c(12,7,11))
# strictly-convex delta-hedron ５種
hexa <- rbind(c(1,2,3),c(1,3,4),c(1,4,2),c(5,3,2),c(5,4,3),c(5,2,4))
deca <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,5,6),c(1,6,2),c(7,3,2),c(7,4,3),c(7,5,4),c(7,6,5),c(7,2,6))
# decaは５角錐の張り合わせ。dodecaはその張り合わせ部分に２つの三角形を割り込ませたもの
dodeca <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,5,6),c(1,6,2),c(7,3,2),c(7,4,3),c(7,5,4),c(7,8,5),c(7,2,8),c(2,6,8),c(8,6,5))
# 正三角柱(側面は正方形)の側面に正四角錐を張り付け
tetracaideca <- rbind(c(1,2,3),c(7,8,9),c(4,2,1),c(4,1,7),c(4,7,8),c(4,8,2),c(5,3,2),c(5,2,8),c(5,8,9),c(5,9,3),c(6,1,3),c(6,3,9),c(6,9,7),c(6,7,1))
# 正四角錐で正四角反柱をサンドイッチ
heccaideca <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,5,2),c(10,7,6),c(10,8,7),c(10,9,8),c(10,6,9),c(2,6,3),c(3,7,4),c(4,8,5),c(5,9,2),c(3,6,7),c(4,7,8),c(5,8,9),c(2,9,6))
# 半正多面体のうち、辺数=3k、頂点数=2kのものの双対は三角メッシュになる
# すべての頂点は合同なので、頂点次数は３であることになるから
# 半正多面体
trunc.tetra <- rbind(c(1,2,3),c(1,3,4),c(1,4,2),c(2,5,3),c(3,6,4),c(4,7,2),c(8,5,2),c(8,3,5),c(8,6,3),c(8,4,6),c(8,7,4),c(8,2,7))
trunc.cube <- rbind(c(1,2,6),c(1,6,3),c(1,3,7),c(1,7,4),c(1,4,8),c(1,8,5),c(1,5,9),c(1,9,2),c(3,6,7),c(4,7,8),c(5,8,9),c(2,9,6),c(6,11,7),c(7,12,8),c(8,13,9),c(9,10,6),c(6,14,11),c(11,14,7),c(7,14,12),c(12,14,8),c(8,14,13),c(13,14,9),c(9,14,10),c(10,14,8))
trunc.octa <- rbind(c(1,2,6),c(1,6,3),c(1,3,7),c(1,7,4),c(1,4,5),c(1,5,2),c(6,2,11),c(6,11,9),c(6,9,12),c(6,12,3),c(7,3,12),c(7,12,10),c(7,10,13),c(7,13,4),c(5,4,13),c(5,13,8),c(5,8,11),c(5,11,2),c(9,14,12),c(12,14,10),c(10,14,13),c(13,14,8),c(8,14,11),c(11,14,9))
trunc.dodeca <- rbind(c(1,2,7),c(1,7,3),c(1,3,8),c(1,8,4),c(1,4,9),c(1,9,5),c(1,5,10),c(1,10,6),c(1,6,11),c(1,11,2),c(2,11,7),c(3,7,8),c(4,8,9),c(5,9,10),c(6,10,11),c(7,12,8),c(8,14,9),c(9,16,10),c(10,18,11),c(11,20,7),c(7,20,26),c(7,26,21),c(7,21,22),c(7,22,12),c(8,12,22),c(8,22,13),c(8,13,23),c(8,23,14),c(9,14,23),c(9,23,15),c(9,15,24),c(9,24,16),c(10,16,22),c(10,22,17),c(10,17,25),c(10,25,18),c(11,18,25),c(11,25,19),c(11,19,26),c(11,26,20),c(21,26,22),c(13,22,23),c(15,23,24),c(17,24,25),c(19,25,26),c(22,26,31),c(22,31,32),c(22,32,27),c(22,27,23),c(23,27,32),c(23,32,28),c(23,28,24),c(24,28,32),c(24,32,29),c(24,20,25),c(25,29,32),c(25,32,30),c(25,30,26),c(26,30,32),c(26,32,31))
trunc.icosa <- rbind(c(1,7,4),c(4,7,8),c(1,9,7),c(1,2,9),c(2,23,9),c(2,3,23),c(3,29,23),c(3,19,29),c(3,13,19),c(2,13,3),c(2,10,13),c(1,10,2),c(1,5,10),c(1,4,5),c(4,6,5),c(4,8,6),c(6,8,17),c(8,26,17),c(17,26,31),c(17,31,16),c(6,17,16),c(11,6,16),c(5,6,11),c(5,11,12),c(10,5,12),c(10,12,13),c(13,12,14),c(13,14,19),c(8,21,26),c(8,7,21),c(7,22,21),c(7,9,22),c(9,23,22),c(22,23,25),c(23,29,25),c(16,31,32),c(16,32,15),c(16,15,11),c(11,15,12),c(12,15,14),c(15,32,18),c(15,18,14),c(14,18,19),c(20,19,18),c(29,19,20),c(26,27,31),c(27,26,24),c(26,21,24),c(21,22,24),c(24,22,25),c(27,24,28),c(24,25,28),c(25,29,28),c(28,29,20),c(31,27,30),c(27,28,30),c(28,20,30),c(32,31,30),c(18,32,30),c(20,18,30))
trunc.cubocuta <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,5,2),c(2,5,9),c(2,9,8),c(2,8,6),c(2,6,3),c(3,6,10),c(3,10,16),c(3,16,11),c(3,11,7),c(3,7,4),c(4,7,12),c(4,12,8),c(4,8,5),c(5,8,13),c(5,13,19),c(5,19,14),c(5,14,9),c(6,15,10),c(7,11,12),c(8,12,13),c(9,14,15),c(10,15,21),c(10,21,22),c(10,22,16),c(16,22,11),c(11,22,17),c(11,17,12),c(12,17,23),c(12,23,18),c(12,18,13),c(13,18,24),c(13,24,19),c(19,24,14),c(14,24,20),c(14,20,15),c(15,20,25),c(15,25,21),c(21,25,22),c(22,25,26),c(22,26,23),c(22,23,17),c(23,26,24),c(23,24,18),c(24,26,25),c(20,24,25))
# truncated icosidodecahedron
# アルキメデスの角柱(プリズム)
# 上面・下面がk角形であり、側面が正方形であるような角柱を考える
# ３正則グラフなので、この双対グラフとしての三角メッシュを作る関数を作る
my.prism.tri <- function(k){
top =1
bottom = k+2
sides = 2:(k+1)
sides <- c(sides,2)
ret <- matrix(0,0,3)
for(i in 1:k){
tmp1 <- c(top,sides[i],sides[i+1])
tmp2 <- c(bottom,sides[i+1],sides[i])
ret <- rbind(ret,tmp1,tmp2)
}
return(ret)
}
my.prism.tri(4)
# 上面・下面が３角形・６角形のそれぞれのアンチプリズム
antiprism3 <- octa # 正八面体のこと
antiprism6 <- rbind(c(1,2,3),c(1,3,4),c(1,4,5),c(1,5,6),c(1,6,7),c(1,7,2),c(14,9,8),c(14,10,9),c(14,11,10),c(14,12,11),c(14,13,12),c(14,8,13),c(2,8,3),c(3,9,4),c(4,10,5),c(5,11,6),c(6,12,7),c(7,13,2),c(3,8,9),c(4,9,10),c(5,10,11),c(6,11,12),c(7,12,13),c(2,13,8))
# icosa
# heccaideca
ico.heccai <- my.paste.tri(icosa, heccaideca, 1,5)
cy.icosa <- my.zigzag.cycle(icosa)
cy.heccaideca <- my.zigzag.cycle(heccaideca)
cy.ico.heccai <-my.zigzag.cycle(ico.heccai)
cy.icosa
cy.heccaideca
cy.ico.heccai
sapply(cy.icosa)
sapply(cy.icosa,length)
sapply(cy.heccaideca,length)
sapply(cy.ico.heccai,length)
dim(iso.heccai)
dim(ico.heccai)
17*3
sum(sapply(cy.ico.heccai,length))
cy.ico.heccai[[1]]
plot(cy.ico.heccai[[1]])
dim(icosa)
range(icosa)
abline(h=27)
plot(cy.ico.heccai[[2]])
abline(h=27)
