---
title: "sqrt of distribution"
author: "ryamada"
date: "2020/5/20"
output: html_document
---

```{r setup, include=FALSE}
library(rgl)
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
knit_hooks$set(webgl = hook_webgl)
```

## DEEF : Decomposition in Extended Exponential Family

Probability density function f is;

$$
f(x ) = e^{C(x) + \sum F(x) \theta - \psi(\Theta)} \\
\int f(x) dx = 1\\
f(x) \ge 0
$$

$$
<f, g> = \int f g dx = \int e^{C(x)_f +C(x)_g+ \sum F(x) (\theta_f + \theta_g) - \psi(\Theta_f + \Theta_g)}
$$

$$
\Theta^T \Theta = (\frac{1}{2} \log{<f_i,f_j>})
$$

## $\sqrt{f}$
Because 
$$
\int f(x) dx = 1\\
f(x) \ge 0,
$$

$$
\int \sqrt{f(x)} dx = 1\\
\sqrt{f(x)} \ge 0
$$

This means $\sqrt{f(x)}$ is a unit vector in its vector space (Hilbert space), or it is on the surface of unit hypersphere $S^{\infty}$.

When $<f,g>$ is calculable, $<\sqrt{f},\sqrt{g}>$ is also calculable.

Because $\sqrt{f} and \sqrt{g}$ are unit vectors, their inner product is $\cos{\phi}$ between them.

The geodesic distance between $\sqrt{f}$ and $\sqrt{g}$ on the unit sphere is $\phi$.

The Euclidean distance between them is $\sqrt{\int (\sqrt{f(x)}-\sqrt{g(x)})^2 dx}$.

The distance is Euclidean, therefore all $\sqrt{f}$ functions can be embed in Euclidean (Hilbert space) nicely. 
And they are on the unit hypersphere.

Let's assume $D$ is the Euclidean distance among $\sqrt{f}$ set.

MDS will give you a nice euclidean coordinates $X$.

## What is the relation $\Theta$ in EEF and $X$ by MDS of $\sqrt{f}$?

At least both coordinate systems will give topologically identical manifolds for a set of distributions.

Also MDS-based Euclidean coordinates for $\sqrt{f}$ would be easy to evaluate manifold structure that is given as a point cloud in which each point stands for a distribution.

This would be true in general; for Andrew-san to handle a set of point clouds data and evaluate them as a manifold in DEEF space (or $\sqrt{f}-based$-Euclidean space.

This might be also eaiser for Ysuri-san to handle "random point pair-basd distribution of curves, generated by manifolds"...

```{r, webgl=TRUE}
# sqrt of distributions
# number of distributions
n.dist <- 100

# Generate multiple instances of distribution with normal distribution & exponential distribution
# mean of normal distribution
m <- sort(runif(n.dist)) 
# sd of normal distribution
sd <- sort((runif(n.dist)+1)^2)
# parameter for exponential distribution
m2 <- sort(runif(n.dist))+3
# Discrete values in support
n.pt <- 500
x <- seq(from=-20,to=20,length=n.pt)
# Generate probability mass distributions
X <- matrix(0,n.pt,n.dist)
for(i in 1:n.dist){
  X[,i] <- dnorm(x,m[i],sd[i]) + dnorm(abs(x),m2[i],1)
  X[,i] <- X[,i]/sum(X[,i])
}
matplot(x,X,type="l")

# Calculate sqrt of mass functions
X.sqrt <- sqrt(X)

# Inner product matrix of mass functions
IP.X <- t(X) %*% X

# Inner product matrix of sqrt(mass function)
IP.X.sqrt <- t(X.sqrt) %*% X.sqrt
IP.X.sqrt[which(IP.X.sqrt>1)] <- 1
par(mfcol=c(1,2))
image(IP.X)
image(IP.X.sqrt)
par(mfcol=c(1,1))

# Apply DEEF to regular mass functions
library(deef)

DEEFout <- DEEF(t(X))

# geodesic distance among sqrt(mass function)

dist.Sphere <- acos(IP.X.sqrt)

# Euclidean distance among sqrt(mass function)
DD <- as.matrix(dist(t(X.sqrt)))

# Add the origin 
#ã€€sqrt(mass function)is on the unit sphere
# the origin point makes their MDS-based coordinates explicit as a unit sphere 
DD3 <- matrix(0,length(DD[,1])+1,length(DD[,1])+1)
DD3[1,] <- DD3[,1] <- 1
DD3[1,1] <- 0
DD3[-1,-1] <- DD

#MDSout <- cmdscale(DD,eig=TRUE,k=49)
MDSout2 <- cmdscale(DD3,eig=TRUE,k=50)

# Shift the coordinates so that the origin should have (0,0,....,0)
MDSout2[[1]] <- t(t(MDSout2[[1]]) - MDSout2[[1]][1,])

#DD2 <- as.matrix(dist(MDSout))
DD4 <- as.matrix(dist(MDSout2[[1]]))

# The manifolds that a set of distributions make are similar.
library(rgl)
plot3d(MDSout2[[1]][,1:3])

plot3d(DEEFout[[2]][,1:3])

par(mfcol=c(2,2))
plot(MDSout2[[1]][,1][-1],DEEFout[[2]][,1])
plot(MDSout2[[1]][,2][-1],DEEFout[[2]][,2])
plot(MDSout2[[1]][,3][-1],DEEFout[[2]][,3])
par(mfcol=c(1,1))

plot3d(rbind(DEEFout[[2]][,1:3],(MDSout2[[1]][,1:3])[-1,]))
spheres3d(DEEFout[[2]][,1:3],radius=0.05,color=4)
spheres3d((MDSout2[[1]][,1:3])[-1,],radius=0.05,color=5)
```